/*
 * generated by Xtext 2.10.0
 */
package org.cirad.dsl.xtext.serializer;

import behaviorMetamodel.ActivityBehavior;
import behaviorMetamodel.ActivityDiagramBehavior;
import behaviorMetamodel.Add;
import behaviorMetamodel.AnonymousFunction;
import behaviorMetamodel.Assignment;
import behaviorMetamodel.AttributeClass;
import behaviorMetamodel.ConstantExpression;
import behaviorMetamodel.Decision;
import behaviorMetamodel.DeclaredAttributes;
import behaviorMetamodel.DeclaredBehavior;
import behaviorMetamodel.DeclaredEntities;
import behaviorMetamodel.DeclaredLocalVariable;
import behaviorMetamodel.DeclaredParameter;
import behaviorMetamodel.DeclaredVariable;
import behaviorMetamodel.Die;
import behaviorMetamodel.End;
import behaviorMetamodel.Entity;
import behaviorMetamodel.Equation;
import behaviorMetamodel.EquationBehavior;
import behaviorMetamodel.Fork;
import behaviorMetamodel.FunctionCallExpression;
import behaviorMetamodel.IfFalseEdge;
import behaviorMetamodel.IfTrueEdge;
import behaviorMetamodel.InitEntity;
import behaviorMetamodel.InitSpace;
import behaviorMetamodel.Join;
import behaviorMetamodel.LocalVariable;
import behaviorMetamodel.Merge;
import behaviorMetamodel.MetamodelPackage;
import behaviorMetamodel.Model;
import behaviorMetamodel.Move;
import behaviorMetamodel.NamedFunction;
import behaviorMetamodel.ParameterClass;
import behaviorMetamodel.Remove;
import behaviorMetamodel.Reproduce;
import behaviorMetamodel.SetVariable;
import behaviorMetamodel.Start;
import behaviorMetamodel.Type;
import behaviorMetamodel.UnconditionedEdge;
import com.google.inject.Inject;
import java.util.Set;
import org.cirad.dsl.xtext.services.BreactiveGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class BreactiveSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BreactiveGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MetamodelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MetamodelPackage.ACTIVITY_BEHAVIOR:
				sequence_ActivityBehavior(context, (ActivityBehavior) semanticObject); 
				return; 
			case MetamodelPackage.ACTIVITY_DIAGRAM_BEHAVIOR:
				sequence_ActivityDiagramBehavior(context, (ActivityDiagramBehavior) semanticObject); 
				return; 
			case MetamodelPackage.ADD:
				sequence_Add(context, (Add) semanticObject); 
				return; 
			case MetamodelPackage.ANONYMOUS_FUNCTION:
				sequence_AnonymousFunction(context, (AnonymousFunction) semanticObject); 
				return; 
			case MetamodelPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case MetamodelPackage.ATTRIBUTE_CLASS:
				sequence_AttributeClass(context, (AttributeClass) semanticObject); 
				return; 
			case MetamodelPackage.CONSTANT_EXPRESSION:
				sequence_ConstantExpression(context, (ConstantExpression) semanticObject); 
				return; 
			case MetamodelPackage.DECISION:
				sequence_Decision(context, (Decision) semanticObject); 
				return; 
			case MetamodelPackage.DECLARED_ATTRIBUTES:
				sequence_DeclaredAttributes(context, (DeclaredAttributes) semanticObject); 
				return; 
			case MetamodelPackage.DECLARED_BEHAVIOR:
				sequence_DeclaredBehavior(context, (DeclaredBehavior) semanticObject); 
				return; 
			case MetamodelPackage.DECLARED_ENTITIES:
				sequence_DeclaredEntities(context, (DeclaredEntities) semanticObject); 
				return; 
			case MetamodelPackage.DECLARED_LOCAL_VARIABLE:
				sequence_DeclaredLocalVariable(context, (DeclaredLocalVariable) semanticObject); 
				return; 
			case MetamodelPackage.DECLARED_PARAMETER:
				sequence_DeclaredParameter(context, (DeclaredParameter) semanticObject); 
				return; 
			case MetamodelPackage.DECLARED_VARIABLE:
				sequence_DeclaredVariable(context, (DeclaredVariable) semanticObject); 
				return; 
			case MetamodelPackage.DIE:
				sequence_Die(context, (Die) semanticObject); 
				return; 
			case MetamodelPackage.END:
				sequence_End(context, (End) semanticObject); 
				return; 
			case MetamodelPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case MetamodelPackage.EQUATION:
				sequence_Equation(context, (Equation) semanticObject); 
				return; 
			case MetamodelPackage.EQUATION_BEHAVIOR:
				sequence_EquationBehaviour(context, (EquationBehavior) semanticObject); 
				return; 
			case MetamodelPackage.FORK:
				sequence_Fork(context, (Fork) semanticObject); 
				return; 
			case MetamodelPackage.FUNCTION_CALL_EXPRESSION:
				if (rule == grammarAccess.getFunctionCallExpressionRule()) {
					sequence_Addition_BooleanGetValueFCExpression_BooleanIsOccuppiedLocationFCExpression_BooleanNumericComparisonFCExpression_BooleanPrimitiveFCExpression_BooleanQuantifiedEntitySetFCEpression_BooleanSetValueFCExpression_BooleanUnaryLogicFCExpression_CountEntityFCExpression_CountVariableFCExpression_EntityOneOfFCExpression_GetAttributeFromEntityFCExpression_LocationPrimitiveFCExpression_MathFCExpression_MaxOneOfLocationFCExpression_Multiplication_OneOfLocationFCExpression_PrimaryArithmeticExpression_SelectConditionalLocationFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNumericNamedFCExpressionRule()
						|| rule == grammarAccess.getArithmeticFCExpressionRule()
						|| rule == grammarAccess.getAdditionRule()
						|| action == grammarAccess.getAdditionAccess().getFunctionCallExpressionArgumentsAction_1_0()
						|| rule == grammarAccess.getMultiplicationRule()
						|| action == grammarAccess.getMultiplicationAccess().getFunctionCallExpressionArgumentsAction_1_0()
						|| rule == grammarAccess.getPrimaryArithmeticExpressionRule()) {
					sequence_Addition_CountEntityFCExpression_CountVariableFCExpression_MathFCExpression_Multiplication_PrimaryArithmeticExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAndExprRule()
						|| action == grammarAccess.getAndExprAccess().getFunctionCallExpressionArgumentsAction_1_0()) {
					sequence_AndExpr_BooleanGetValueFCExpression_BooleanIsOccuppiedLocationFCExpression_BooleanNumericComparisonFCExpression_BooleanPrimitiveFCExpression_BooleanQuantifiedEntitySetFCEpression_BooleanSetValueFCExpression_BooleanUnaryLogicFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanLogicFCExpressionRule()
						|| rule == grammarAccess.getOrExprRule()
						|| action == grammarAccess.getOrExprAccess().getFunctionCallExpressionArgumentsAction_1_0()) {
					sequence_AndExpr_BooleanGetValueFCExpression_BooleanIsOccuppiedLocationFCExpression_BooleanNumericComparisonFCExpression_BooleanPrimitiveFCExpression_BooleanQuantifiedEntitySetFCEpression_BooleanSetValueFCExpression_BooleanUnaryLogicFCExpression_OrExpr(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanNamedFCExpressionRule()
						|| rule == grammarAccess.getPrimaryBooleanExpressionRule()) {
					sequence_BooleanGetValueFCExpression_BooleanIsOccuppiedLocationFCExpression_BooleanNumericComparisonFCExpression_BooleanPrimitiveFCExpression_BooleanQuantifiedEntitySetFCEpression_BooleanSetValueFCExpression_BooleanUnaryLogicFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanGetValueFCExpressionRule()) {
					sequence_BooleanGetValueFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanIsOccuppiedLocationFCExpressionRule()) {
					sequence_BooleanIsOccuppiedLocationFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanNumericComparisonFCExpressionRule()) {
					sequence_BooleanNumericComparisonFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanPrimitiveFCExpressionRule()) {
					sequence_BooleanPrimitiveFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanQuantifiedEntitySetFCEpressionRule()) {
					sequence_BooleanQuantifiedEntitySetFCEpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanSetValueFCExpressionRule()) {
					sequence_BooleanSetValueFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanUnaryLogicFCExpressionRule()) {
					sequence_BooleanUnaryLogicFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCountFCExpressionRule()) {
					sequence_CountEntityFCExpression_CountVariableFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCountEntityFCExpressionRule()) {
					sequence_CountEntityFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCountVariableFCExpressionRule()) {
					sequence_CountVariableFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntityNamedFCExpressionRule()
						|| rule == grammarAccess.getEntityOneOfFCExpressionRule()) {
					sequence_EntityOneOfFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntitySetFunctionCallExpressionRule()) {
					sequence_EntitySetConditionalFCExpression_EntitySetOnLocationFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntitySetConditionalFCExpressionRule()) {
					sequence_EntitySetConditionalFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntitySetCreateFCExpressionRule()) {
					sequence_EntitySetCreateFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntitySetOnLocationFCExpressionRule()) {
					sequence_EntitySetOnLocationFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getGetNamedFCExpressionRule()
						|| rule == grammarAccess.getGetAttributeFromEntityFCExpressionRule()) {
					sequence_GetAttributeFromEntityFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getGetEntityNameFCExpressionRule()) {
					sequence_GetEntityNameFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getGetLocalVariableFCExpressionRule()) {
					sequence_GetLocalVariableFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getGetParametersFCExpressionRule()) {
					sequence_GetParametersFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLocationPrimitiveFCExpressionRule()) {
					sequence_LocationPrimitiveFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLocationNamedFCExpressionRule()) {
					sequence_LocationPrimitiveFCExpression_MaxOneOfLocationFCExpression_OneOfLocationFCExpression_SelectConditionalLocationFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMathFCExpressionRule()) {
					sequence_MathFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMaxOneOfLocationFCExpressionRule()) {
					sequence_MaxOneOfLocationFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNeighborFCExpressionRule()) {
					sequence_NeighborFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLocationSetNamedFCExpressionRule()) {
					sequence_NeighborFCExpression_SpaceFCExpression_UnionLocationFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOneOfLocationFCExpressionRule()) {
					sequence_OneOfLocationFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSelectConditionalLocationFCExpressionRule()) {
					sequence_SelectConditionalLocationFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSetAttributeNamedFCExpressionRule()) {
					sequence_SetAttributeNamedFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSetNamedFunctionExpressionRule()) {
					sequence_SetAttributeNamedFCExpression_SetLocationNamedFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSetLocationNamedFCExpressionRule()) {
					sequence_SetLocationNamedFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSpaceFCExpressionRule()) {
					sequence_SpaceFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSpaceInitFCExpressionRule()) {
					sequence_SpaceInitFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnionLocationFCExpressionRule()) {
					sequence_UnionLocationFCExpression(context, (FunctionCallExpression) semanticObject); 
					return; 
				}
				else break;
			case MetamodelPackage.IF_FALSE_EDGE:
				sequence_FalseEdge(context, (IfFalseEdge) semanticObject); 
				return; 
			case MetamodelPackage.IF_TRUE_EDGE:
				sequence_TrueEdge(context, (IfTrueEdge) semanticObject); 
				return; 
			case MetamodelPackage.INIT_ENTITY:
				sequence_InitEntity(context, (InitEntity) semanticObject); 
				return; 
			case MetamodelPackage.INIT_SPACE:
				sequence_InitSpace(context, (InitSpace) semanticObject); 
				return; 
			case MetamodelPackage.JOIN:
				sequence_Join(context, (Join) semanticObject); 
				return; 
			case MetamodelPackage.LOCAL_VARIABLE:
				sequence_LocalVariableClass(context, (LocalVariable) semanticObject); 
				return; 
			case MetamodelPackage.MERGE:
				sequence_Merge(context, (Merge) semanticObject); 
				return; 
			case MetamodelPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MetamodelPackage.MOVE:
				sequence_Move(context, (Move) semanticObject); 
				return; 
			case MetamodelPackage.NAMED_FUNCTION:
				if (rule == grammarAccess.getNumericNamedFunctionRule()) {
					sequence_ArithmeticFunctionMultiplication_ArithmeticFunctionPlus_CountFunction_UnaryMathBinaryFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getArithmeticFunctionRule()) {
					sequence_ArithmeticFunctionMultiplication_ArithmeticFunctionPlus(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getArithmeticFunctionMultiplicationRule()) {
					sequence_ArithmeticFunctionMultiplication(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getArithmeticFunctionPlusRule()) {
					sequence_ArithmeticFunctionPlus(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanNamedFunctionRule()) {
					sequence_BooleanANDBinaryLogicFunction_BooleanGetFunction_BooleanIsOccuppiedLocationFunction_BooleanNumericComparisonFunction_BooleanORBinaryLogicFunction_BooleanPrimitiveFunction_BooleanSetFunction_BooleanUnaryLogicFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanLogicFunctionRule()) {
					sequence_BooleanANDBinaryLogicFunction_BooleanORBinaryLogicFunction_BooleanUnaryLogicFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanANDBinaryLogicFunctionRule()) {
					sequence_BooleanANDBinaryLogicFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanGetFunctionRule()) {
					sequence_BooleanGetFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanIsOccuppiedLocationFunctionRule()) {
					sequence_BooleanIsOccuppiedLocationFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanNumericComparisonFunctionRule()) {
					sequence_BooleanNumericComparisonFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanORBinaryLogicFunctionRule()) {
					sequence_BooleanORBinaryLogicFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanPrimitiveFunctionRule()) {
					sequence_BooleanPrimitiveFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanSetFunctionRule()) {
					sequence_BooleanSetFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanUnaryLogicFunctionRule()) {
					sequence_BooleanUnaryLogicFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCountFunctionRule()) {
					sequence_CountFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntityNamedFunctionRule()) {
					sequence_EntityAllQuantifierFunction_EntityAnyQuantifierFunction_EntityOneOfFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntityQuantifierFunctionRule()) {
					sequence_EntityAllQuantifierFunction_EntityAnyQuantifierFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntityAllQuantifierFunctionRule()) {
					sequence_EntityAllQuantifierFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntityAnyQuantifierFunctionRule()) {
					sequence_EntityAnyQuantifierFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntityOneOfFunctionRule()) {
					sequence_EntityOneOfFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntitySetConditionalFunctionRule()) {
					sequence_EntitySetConditionalFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntitySetCreateFunctionRule()) {
					sequence_EntitySetCreateFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntitySetOnLocationFunctionRule()) {
					sequence_EntitySetOnLocationFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getGetEntityFromLocationNamedFunctionRule()) {
					sequence_GetEntityFromLocationNamedFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getGetNamedFunctionRule()) {
					sequence_GetEntityNamedFunction_GetVariableFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getGetEntityNamedFunctionRule()) {
					sequence_GetEntityNamedFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getGetVariableFunctionRule()) {
					sequence_GetVariableFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLocationNamedFunctionRule()) {
					sequence_LocationPrimitiveFunction_MaxOneOfLocationFunction_NeighborhoodLocationFunction_OneOfLocationFunction_SelectConditionalLocationFunction_SpaceLocationFunction_UnionLocationFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleLocationNamedFunctionRule()) {
					sequence_LocationPrimitiveFunction_MaxOneOfLocationFunction_OneOfLocationFunction_SelectConditionalLocationFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLocationPrimitiveFunctionRule()) {
					sequence_LocationPrimitiveFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMaxOneOfLocationFunctionRule()) {
					sequence_MaxOneOfLocationFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNeighborhoodLocationFunctionRule()) {
					sequence_NeighborhoodLocationFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLocationSetNamedFunctionRule()) {
					sequence_NeighborhoodLocationFunction_SpaceLocationFunction_UnionLocationFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOneOfLocationFunctionRule()) {
					sequence_OneOfLocationFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getQuantififiedLocationRule()) {
					sequence_QuantififiedLocation(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSelectConditionalLocationFunctionRule()) {
					sequence_SelectConditionalLocationFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSpaceInitFunctionRule()) {
					sequence_SpaceInitFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSpaceLocationFunctionRule()) {
					sequence_SpaceLocationFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMathFunctionRule()
						|| rule == grammarAccess.getUnaryMathBinaryFunctionRule()) {
					sequence_UnaryMathBinaryFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnionLocationFunctionRule()) {
					sequence_UnionLocationFunction(context, (NamedFunction) semanticObject); 
					return; 
				}
				else break;
			case MetamodelPackage.PARAMETER_CLASS:
				sequence_ParameterClass(context, (ParameterClass) semanticObject); 
				return; 
			case MetamodelPackage.REMOVE:
				sequence_Remove(context, (Remove) semanticObject); 
				return; 
			case MetamodelPackage.REPRODUCE:
				sequence_Reproduce(context, (Reproduce) semanticObject); 
				return; 
			case MetamodelPackage.SET_VARIABLE:
				sequence_Set(context, (SetVariable) semanticObject); 
				return; 
			case MetamodelPackage.START:
				sequence_Start(context, (Start) semanticObject); 
				return; 
			case MetamodelPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case MetamodelPackage.UNCONDITIONED_EDGE:
				sequence_UnconditionedEdge(context, (UnconditionedEdge) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Behavior returns ActivityBehavior
	 *     ActivityBehavior returns ActivityBehavior
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (parameters+=ParameterClass parameters+=ParameterClass*)? 
	 *         (localvariable+=LocalVariableClass localvariable+=LocalVariableClass*)? 
	 *         (primitiveaactivities+=PrimitiveActivities primitiveaactivities+=PrimitiveActivities*)?
	 *     )
	 */
	protected void sequence_ActivityBehavior(ISerializationContext context, ActivityBehavior semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Behavior returns ActivityDiagramBehavior
	 *     ActivityDiagramBehavior returns ActivityDiagramBehavior
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (parameters+=ParameterClass parameters+=ParameterClass*)? 
	 *         (localvariable+=LocalVariableClass localvariable+=LocalVariableClass*)? 
	 *         start=Start
	 *     )
	 */
	protected void sequence_ActivityDiagramBehavior(ISerializationContext context, ActivityDiagramBehavior semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Add
	 *     ExcecutableNode returns Add
	 *     PrimitiveActivities returns Add
	 *     Add returns Add
	 *
	 * Constraint:
	 *     (name='Add' expression+=FunctionCallExpression toAttribute=DeclaredAttributes outcome_edge+=UnconditionedEdge?)
	 */
	protected void sequence_Add(ISerializationContext context, Add semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCallExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             function=EntityQuantifierFunction 
	 *             arguments+=DeclaredEntities 
	 *             arguments+=LocationPrimitiveFCExpression 
	 *             arguments+=BooleanNumericComparisonFCExpression
	 *         ) | 
	 *         function=BooleanPrimitiveFunction | 
	 *         (function=BooleanSetFunction arguments+=DeclaredVariable) | 
	 *         (function=BooleanGetFunction arguments+=DeclaredVariable) | 
	 *         (
	 *             (arguments+=DeclaredVariable | arguments+=ConstantExpression) 
	 *             function=BooleanNumericComparisonFunction 
	 *             (arguments+=DeclaredVariable | arguments+=ConstantExpression)
	 *         ) | 
	 *         (
	 *             arguments+=LocationPrimitiveFCExpression 
	 *             arguments+=BooleanUnaryLogicFCExpression? 
	 *             function=BooleanIsOccuppiedLocationFunction 
	 *             (arguments+=EntitySetConditionalFCExpression arguments+=EntitySetConditionalFCExpression*)?
	 *         ) | 
	 *         function=BooleanUnaryLogicFunction | 
	 *         (
	 *             function=EntityOneOfFunction 
	 *             arguments+=DeclaredEntities 
	 *             arguments+=LocationNamedFCExpression 
	 *             (arguments+=BooleanLogicFCExpression arguments+=BooleanLogicFCExpression*)?
	 *         ) | 
	 *         (arguments+=Addition_FunctionCallExpression_1_0 function=ArithmeticFunctionPlus arguments+=Multiplication) | 
	 *         (arguments+=Multiplication_FunctionCallExpression_1_0 function=ArithmeticFunctionMultiplication arguments+=PrimaryArithmeticExpression) | 
	 *         arguments+=DeclaredVariable | 
	 *         arguments+=ConstantExpression | 
	 *         (function=CountFunction arguments+=DeclaredVariable) | 
	 *         (function=CountFunction arguments+=EntitySetConditionalFCExpression) | 
	 *         (function=MathFunction arguments+=NumericNamedFCExpression) | 
	 *         (
	 *             arguments+=DeclaredVariable 
	 *             function=GetVariableFunction 
	 *             (arguments+=EntityNamedFCExpression | arguments+=DeclaredEntities) 
	 *             arguments+=LocationNamedFCExpression?
	 *         ) | 
	 *         (
	 *             function=MaxOneOfLocationFunction 
	 *             arguments+=DeclaredAttributes 
	 *             (arguments+=SelectConditionalLocationFCExpression | arguments+=UnionLocationFCExpression) 
	 *             arguments+=UnionLocationFCExpression?
	 *         ) | 
	 *         (
	 *             function=OneOfLocationFunction 
	 *             arguments+=SelectConditionalLocationFCExpression? 
	 *             arguments+=LocationSetNamedFCExpression? 
	 *             arguments+=DeclaredLocalVariable?
	 *         ) | 
	 *         (function=SelectConditionalLocationFunction arguments+=LocationPrimitiveFCExpression arguments+=BooleanLogicFCExpression) | 
	 *         function=LocationPrimitiveFunction
	 *     )
	 */
	protected void sequence_Addition_BooleanGetValueFCExpression_BooleanIsOccuppiedLocationFCExpression_BooleanNumericComparisonFCExpression_BooleanPrimitiveFCExpression_BooleanQuantifiedEntitySetFCEpression_BooleanSetValueFCExpression_BooleanUnaryLogicFCExpression_CountEntityFCExpression_CountVariableFCExpression_EntityOneOfFCExpression_GetAttributeFromEntityFCExpression_LocationPrimitiveFCExpression_MathFCExpression_MaxOneOfLocationFCExpression_Multiplication_OneOfLocationFCExpression_PrimaryArithmeticExpression_SelectConditionalLocationFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NumericNamedFCExpression returns FunctionCallExpression
	 *     ArithmeticFCExpression returns FunctionCallExpression
	 *     Addition returns FunctionCallExpression
	 *     Addition.FunctionCallExpression_1_0 returns FunctionCallExpression
	 *     Multiplication returns FunctionCallExpression
	 *     Multiplication.FunctionCallExpression_1_0 returns FunctionCallExpression
	 *     PrimaryArithmeticExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (
	 *         (arguments+=Addition_FunctionCallExpression_1_0 function=ArithmeticFunctionPlus arguments+=Multiplication) | 
	 *         (arguments+=Multiplication_FunctionCallExpression_1_0 function=ArithmeticFunctionMultiplication arguments+=PrimaryArithmeticExpression) | 
	 *         arguments+=DeclaredVariable | 
	 *         arguments+=ConstantExpression | 
	 *         (function=CountFunction arguments+=DeclaredVariable) | 
	 *         (function=CountFunction arguments+=EntitySetConditionalFCExpression) | 
	 *         (function=MathFunction arguments+=NumericNamedFCExpression)
	 *     )
	 */
	protected void sequence_Addition_CountEntityFCExpression_CountVariableFCExpression_MathFCExpression_Multiplication_PrimaryArithmeticExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AndExpr returns FunctionCallExpression
	 *     AndExpr.FunctionCallExpression_1_0 returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             function=EntityQuantifierFunction 
	 *             arguments+=DeclaredEntities 
	 *             arguments+=LocationPrimitiveFCExpression 
	 *             arguments+=BooleanNumericComparisonFCExpression
	 *         ) | 
	 *         function=BooleanPrimitiveFunction | 
	 *         (function=BooleanSetFunction arguments+=DeclaredVariable) | 
	 *         (function=BooleanGetFunction arguments+=DeclaredVariable) | 
	 *         (
	 *             (arguments+=DeclaredVariable | arguments+=ConstantExpression) 
	 *             function=BooleanNumericComparisonFunction 
	 *             (arguments+=DeclaredVariable | arguments+=ConstantExpression)
	 *         ) | 
	 *         (
	 *             arguments+=LocationPrimitiveFCExpression 
	 *             arguments+=BooleanUnaryLogicFCExpression? 
	 *             function=BooleanIsOccuppiedLocationFunction 
	 *             (arguments+=EntitySetConditionalFCExpression arguments+=EntitySetConditionalFCExpression*)?
	 *         ) | 
	 *         (arguments+=AndExpr_FunctionCallExpression_1_0 function=BooleanANDBinaryLogicFunction arguments+=PrimaryBooleanExpression) | 
	 *         function=BooleanUnaryLogicFunction
	 *     )
	 */
	protected void sequence_AndExpr_BooleanGetValueFCExpression_BooleanIsOccuppiedLocationFCExpression_BooleanNumericComparisonFCExpression_BooleanPrimitiveFCExpression_BooleanQuantifiedEntitySetFCEpression_BooleanSetValueFCExpression_BooleanUnaryLogicFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanLogicFCExpression returns FunctionCallExpression
	 *     OrExpr returns FunctionCallExpression
	 *     OrExpr.FunctionCallExpression_1_0 returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             function=EntityQuantifierFunction 
	 *             arguments+=DeclaredEntities 
	 *             arguments+=LocationPrimitiveFCExpression 
	 *             arguments+=BooleanNumericComparisonFCExpression
	 *         ) | 
	 *         function=BooleanPrimitiveFunction | 
	 *         (function=BooleanSetFunction arguments+=DeclaredVariable) | 
	 *         (function=BooleanGetFunction arguments+=DeclaredVariable) | 
	 *         (
	 *             (arguments+=DeclaredVariable | arguments+=ConstantExpression) 
	 *             function=BooleanNumericComparisonFunction 
	 *             (arguments+=DeclaredVariable | arguments+=ConstantExpression)
	 *         ) | 
	 *         (
	 *             arguments+=LocationPrimitiveFCExpression 
	 *             arguments+=BooleanUnaryLogicFCExpression? 
	 *             function=BooleanIsOccuppiedLocationFunction 
	 *             (arguments+=EntitySetConditionalFCExpression arguments+=EntitySetConditionalFCExpression*)?
	 *         ) | 
	 *         (arguments+=AndExpr_FunctionCallExpression_1_0 function=BooleanANDBinaryLogicFunction arguments+=PrimaryBooleanExpression) | 
	 *         (arguments+=OrExpr_FunctionCallExpression_1_0 function=BooleanORBinaryLogicFunction arguments+=AndExpr) | 
	 *         function=BooleanUnaryLogicFunction
	 *     )
	 */
	protected void sequence_AndExpr_BooleanGetValueFCExpression_BooleanIsOccuppiedLocationFCExpression_BooleanNumericComparisonFCExpression_BooleanPrimitiveFCExpression_BooleanQuantifiedEntitySetFCEpression_BooleanSetValueFCExpression_BooleanUnaryLogicFCExpression_OrExpr(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnonymousFunction returns AnonymousFunction
	 *
	 * Constraint:
	 *     ((parameters+=ParameterClass parameters+=ParameterClass*)? expression=FunctionCallExpression)
	 */
	protected void sequence_AnonymousFunction(ISerializationContext context, AnonymousFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NumericNamedFunction returns NamedFunction
	 *
	 * Constraint:
	 *     (
	 *         name='+' | 
	 *         name='-' | 
	 *         name='/' | 
	 *         name='*' | 
	 *         name='sqrt' | 
	 *         name='random' | 
	 *         name='floor' | 
	 *         name='exp' | 
	 *         name='count'
	 *     )
	 */
	protected void sequence_ArithmeticFunctionMultiplication_ArithmeticFunctionPlus_CountFunction_UnaryMathBinaryFunction(ISerializationContext context, NamedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticFunction returns NamedFunction
	 *
	 * Constraint:
	 *     (name='+' | name='-' | name='/' | name='*')
	 */
	protected void sequence_ArithmeticFunctionMultiplication_ArithmeticFunctionPlus(ISerializationContext context, NamedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticFunctionMultiplication returns NamedFunction
	 *
	 * Constraint:
	 *     (name='+' | name='-')
	 */
	protected void sequence_ArithmeticFunctionMultiplication(ISerializationContext context, NamedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticFunctionPlus returns NamedFunction
	 *
	 * Constraint:
	 *     (name='/' | name='*')
	 */
	protected void sequence_ArithmeticFunctionPlus(ISerializationContext context, NamedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (variable=DeclaredVariable expression=FunctionCallExpression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.ASSIGNMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.ASSIGNMENT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.ASSIGNMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.ASSIGNMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getVariableDeclaredVariableParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getAssignmentAccess().getExpressionFunctionCallExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeClass returns AttributeClass
	 *
	 * Constraint:
	 *     (name=ID type=TypeEnum)
	 */
	protected void sequence_AttributeClass(ISerializationContext context, AttributeClass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.VARIABLE_CLASS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.VARIABLE_CLASS__NAME));
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.VARIABLE_CLASS__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.VARIABLE_CLASS__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeClassAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAttributeClassAccess().getTypeTypeEnumEnumRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanNamedFunction returns NamedFunction
	 *
	 * Constraint:
	 *     (
	 *         name='true' | 
	 *         name='false' | 
	 *         name='set' | 
	 *         name='get' | 
	 *         name='>=' | 
	 *         name='>' | 
	 *         name='!=' | 
	 *         name='<' | 
	 *         name='<=' | 
	 *         name='=' | 
	 *         name='occupied' | 
	 *         name='NOT' | 
	 *         name='AND' | 
	 *         name='OR'
	 *     )
	 */
	protected void sequence_BooleanANDBinaryLogicFunction_BooleanGetFunction_BooleanIsOccuppiedLocationFunction_BooleanNumericComparisonFunction_BooleanORBinaryLogicFunction_BooleanPrimitiveFunction_BooleanSetFunction_BooleanUnaryLogicFunction(ISerializationContext context, NamedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanLogicFunction returns NamedFunction
	 *
	 * Constraint:
	 *     (name='NOT' | name='AND' | name='OR')
	 */
	protected void sequence_BooleanANDBinaryLogicFunction_BooleanORBinaryLogicFunction_BooleanUnaryLogicFunction(ISerializationContext context, NamedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanANDBinaryLogicFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='AND'
	 */
	protected void sequence_BooleanANDBinaryLogicFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanANDBinaryLogicFunctionAccess().getNameANDKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanGetFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='get'
	 */
	protected void sequence_BooleanGetFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanGetFunctionAccess().getNameGetKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanNamedFCExpression returns FunctionCallExpression
	 *     PrimaryBooleanExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             function=EntityQuantifierFunction 
	 *             arguments+=DeclaredEntities 
	 *             arguments+=LocationPrimitiveFCExpression 
	 *             arguments+=BooleanNumericComparisonFCExpression
	 *         ) | 
	 *         function=BooleanPrimitiveFunction | 
	 *         (function=BooleanSetFunction arguments+=DeclaredVariable) | 
	 *         (function=BooleanGetFunction arguments+=DeclaredVariable) | 
	 *         (
	 *             (arguments+=DeclaredVariable | arguments+=ConstantExpression) 
	 *             function=BooleanNumericComparisonFunction 
	 *             (arguments+=DeclaredVariable | arguments+=ConstantExpression)
	 *         ) | 
	 *         (
	 *             arguments+=LocationPrimitiveFCExpression 
	 *             arguments+=BooleanUnaryLogicFCExpression? 
	 *             function=BooleanIsOccuppiedLocationFunction 
	 *             (arguments+=EntitySetConditionalFCExpression arguments+=EntitySetConditionalFCExpression*)?
	 *         ) | 
	 *         function=BooleanUnaryLogicFunction
	 *     )
	 */
	protected void sequence_BooleanGetValueFCExpression_BooleanIsOccuppiedLocationFCExpression_BooleanNumericComparisonFCExpression_BooleanPrimitiveFCExpression_BooleanQuantifiedEntitySetFCEpression_BooleanSetValueFCExpression_BooleanUnaryLogicFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanGetValueFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (function=BooleanGetFunction arguments+=DeclaredVariable)
	 */
	protected void sequence_BooleanGetValueFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanIsOccuppiedLocationFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (
	 *         arguments+=LocationPrimitiveFCExpression 
	 *         arguments+=BooleanUnaryLogicFCExpression? 
	 *         function=BooleanIsOccuppiedLocationFunction 
	 *         (arguments+=EntitySetConditionalFCExpression arguments+=EntitySetConditionalFCExpression*)?
	 *     )
	 */
	protected void sequence_BooleanIsOccuppiedLocationFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanIsOccuppiedLocationFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='occupied'
	 */
	protected void sequence_BooleanIsOccuppiedLocationFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanIsOccuppiedLocationFunctionAccess().getNameOccupiedKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanNumericComparisonFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (
	 *         (arguments+=DeclaredVariable | arguments+=ConstantExpression) 
	 *         function=BooleanNumericComparisonFunction 
	 *         (arguments+=DeclaredVariable | arguments+=ConstantExpression)
	 *     )
	 */
	protected void sequence_BooleanNumericComparisonFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanNumericComparisonFunction returns NamedFunction
	 *
	 * Constraint:
	 *     (
	 *         name='>=' | 
	 *         name='>' | 
	 *         name='!=' | 
	 *         name='<' | 
	 *         name='<=' | 
	 *         name='='
	 *     )
	 */
	protected void sequence_BooleanNumericComparisonFunction(ISerializationContext context, NamedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanORBinaryLogicFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='OR'
	 */
	protected void sequence_BooleanORBinaryLogicFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanORBinaryLogicFunctionAccess().getNameORKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanPrimitiveFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     function=BooleanPrimitiveFunction
	 */
	protected void sequence_BooleanPrimitiveFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.FUNCTION_CALL_EXPRESSION__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.FUNCTION_CALL_EXPRESSION__FUNCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanPrimitiveFCExpressionAccess().getFunctionBooleanPrimitiveFunctionParserRuleCall_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanPrimitiveFunction returns NamedFunction
	 *
	 * Constraint:
	 *     (name='true' | name='false')
	 */
	protected void sequence_BooleanPrimitiveFunction(ISerializationContext context, NamedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanQuantifiedEntitySetFCEpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (
	 *         function=EntityQuantifierFunction 
	 *         arguments+=DeclaredEntities 
	 *         arguments+=LocationPrimitiveFCExpression 
	 *         arguments+=BooleanNumericComparisonFCExpression
	 *     )
	 */
	protected void sequence_BooleanQuantifiedEntitySetFCEpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanSetFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='set'
	 */
	protected void sequence_BooleanSetFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanSetFunctionAccess().getNameSetKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanSetValueFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (function=BooleanSetFunction arguments+=DeclaredVariable)
	 */
	protected void sequence_BooleanSetValueFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanUnaryLogicFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     function=BooleanUnaryLogicFunction
	 */
	protected void sequence_BooleanUnaryLogicFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.FUNCTION_CALL_EXPRESSION__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.FUNCTION_CALL_EXPRESSION__FUNCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanUnaryLogicFCExpressionAccess().getFunctionBooleanUnaryLogicFunctionParserRuleCall_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanUnaryLogicFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='NOT'
	 */
	protected void sequence_BooleanUnaryLogicFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanUnaryLogicFunctionAccess().getNameNOTKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstantExpression returns ConstantExpression
	 *
	 * Constraint:
	 *     value=Float
	 */
	protected void sequence_ConstantExpression(ISerializationContext context, ConstantExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.CONSTANT_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.CONSTANT_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantExpressionAccess().getValueFloatParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CountFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     ((function=CountFunction arguments+=DeclaredVariable) | (function=CountFunction arguments+=EntitySetConditionalFCExpression))
	 */
	protected void sequence_CountEntityFCExpression_CountVariableFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CountEntityFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (function=CountFunction arguments+=EntitySetConditionalFCExpression)
	 */
	protected void sequence_CountEntityFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CountFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='count'
	 */
	protected void sequence_CountFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCountFunctionAccess().getNameCountKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CountVariableFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (function=CountFunction arguments+=DeclaredVariable)
	 */
	protected void sequence_CountVariableFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Decision
	 *     ControlNode returns Decision
	 *     Decision returns Decision
	 *
	 * Constraint:
	 *     (
	 *         name='Decide ' 
	 *         (booleanexpression+=BooleanNamedFCExpression booleanexpression+=BooleanLogicFCExpression*)? 
	 *         outcome_edge+=TrueEdge 
	 *         outcome_edge+=FalseEdge?
	 *     )
	 */
	protected void sequence_Decision(ISerializationContext context, Decision semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclaredAttributes returns DeclaredAttributes
	 *
	 * Constraint:
	 *     attributeclass=[AttributeClass|QualifiedName]
	 */
	protected void sequence_DeclaredAttributes(ISerializationContext context, DeclaredAttributes semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.DECLARED_ATTRIBUTES__ATTRIBUTECLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.DECLARED_ATTRIBUTES__ATTRIBUTECLASS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclaredAttributesAccess().getAttributeclassAttributeClassQualifiedNameParserRuleCall_0_1(), semanticObject.getAttributeclass());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Node returns DeclaredBehavior
	 *     DeclaredBehavior returns DeclaredBehavior
	 *
	 * Constraint:
	 *     (behavior=[Behavior|QualifiedName] outcome_edge+=UnconditionedEdge)
	 */
	protected void sequence_DeclaredBehavior(ISerializationContext context, DeclaredBehavior semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclaredEntities returns DeclaredEntities
	 *
	 * Constraint:
	 *     entity=[Entity|QualifiedName]
	 */
	protected void sequence_DeclaredEntities(ISerializationContext context, DeclaredEntities semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.DECLARED_ENTITIES__ENTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.DECLARED_ENTITIES__ENTITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclaredEntitiesAccess().getEntityEntityQualifiedNameParserRuleCall_0_1(), semanticObject.getEntity());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeclaredLocalVariable returns DeclaredLocalVariable
	 *
	 * Constraint:
	 *     localvariable=[LocalVariable|ID]
	 */
	protected void sequence_DeclaredLocalVariable(ISerializationContext context, DeclaredLocalVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.DECLARED_LOCAL_VARIABLE__LOCALVARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.DECLARED_LOCAL_VARIABLE__LOCALVARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclaredLocalVariableAccess().getLocalvariableLocalVariableIDTerminalRuleCall_1_0_1(), semanticObject.getLocalvariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeclaredParameter returns DeclaredParameter
	 *
	 * Constraint:
	 *     parameterclass=[ParameterClass|QualifiedName]
	 */
	protected void sequence_DeclaredParameter(ISerializationContext context, DeclaredParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.DECLARED_PARAMETER__PARAMETERCLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.DECLARED_PARAMETER__PARAMETERCLASS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclaredParameterAccess().getParameterclassParameterClassQualifiedNameParserRuleCall_1_0_1(), semanticObject.getParameterclass());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeclaredVariable returns DeclaredVariable
	 *
	 * Constraint:
	 *     variableclass=[VariableClass|QualifiedName]
	 */
	protected void sequence_DeclaredVariable(ISerializationContext context, DeclaredVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.DECLARED_VARIABLE__VARIABLECLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.DECLARED_VARIABLE__VARIABLECLASS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclaredVariableAccess().getVariableclassVariableClassQualifiedNameParserRuleCall_1_0_1(), semanticObject.getVariableclass());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Die
	 *     ExcecutableNode returns Die
	 *     PrimitiveActivities returns Die
	 *     Die returns Die
	 *
	 * Constraint:
	 *     (name='Die' outcome_edge+=UnconditionedEdge?)
	 */
	protected void sequence_Die(ISerializationContext context, Die semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns End
	 *     ControlNode returns End
	 *     End returns End
	 *
	 * Constraint:
	 *     name='End'
	 */
	protected void sequence_End(ISerializationContext context, End semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEndAccess().getNameEndKeyword_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntityNamedFunction returns NamedFunction
	 *
	 * Constraint:
	 *     (name='any' | name='all' | name='one-of')
	 */
	protected void sequence_EntityAllQuantifierFunction_EntityAnyQuantifierFunction_EntityOneOfFunction(ISerializationContext context, NamedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntityQuantifierFunction returns NamedFunction
	 *
	 * Constraint:
	 *     (name='any' | name='all')
	 */
	protected void sequence_EntityAllQuantifierFunction_EntityAnyQuantifierFunction(ISerializationContext context, NamedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntityAllQuantifierFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='all'
	 */
	protected void sequence_EntityAllQuantifierFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntityAllQuantifierFunctionAccess().getNameAllKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntityAnyQuantifierFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='any'
	 */
	protected void sequence_EntityAnyQuantifierFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntityAnyQuantifierFunctionAccess().getNameAnyKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntityNamedFCExpression returns FunctionCallExpression
	 *     EntityOneOfFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (
	 *         function=EntityOneOfFunction 
	 *         arguments+=DeclaredEntities 
	 *         arguments+=LocationNamedFCExpression 
	 *         (arguments+=BooleanLogicFCExpression arguments+=BooleanLogicFCExpression*)?
	 *     )
	 */
	protected void sequence_EntityOneOfFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntityOneOfFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='one-of'
	 */
	protected void sequence_EntityOneOfFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntityOneOfFunctionAccess().getNameOneOfKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntitySetFunctionCallExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (
	 *         (arguments+=DeclaredEntities function=EntitySetOnLocationFunction arguments+=LocationPrimitiveFCExpression) | 
	 *         (function=EntityNamedFunction? arguments+=DeclaredEntities arguments+=LocationPrimitiveFCExpression arguments+=BooleanLogicFCExpression?)
	 *     )
	 */
	protected void sequence_EntitySetConditionalFCExpression_EntitySetOnLocationFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntitySetConditionalFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (function=EntityNamedFunction? arguments+=DeclaredEntities arguments+=LocationPrimitiveFCExpression arguments+=BooleanLogicFCExpression?)
	 */
	protected void sequence_EntitySetConditionalFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntitySetConditionalFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='has'
	 */
	protected void sequence_EntitySetConditionalFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntitySetConditionalFunctionAccess().getNameHasKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntitySetCreateFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (function=EntitySetCreateFunction arguments+=DeclaredEntities arguments+=ConstantExpression)
	 */
	protected void sequence_EntitySetCreateFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntitySetCreateFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='Create '
	 */
	protected void sequence_EntitySetCreateFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntitySetCreateFunctionAccess().getNameCreateKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntitySetOnLocationFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (arguments+=DeclaredEntities function=EntitySetOnLocationFunction arguments+=LocationPrimitiveFCExpression)
	 */
	protected void sequence_EntitySetOnLocationFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntitySetOnLocationFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='on'
	 */
	protected void sequence_EntitySetOnLocationFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntitySetOnLocationFunctionAccess().getNameOnKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     (name=ID (attributes+=AttributeClass attributes+=AttributeClass*)? (behavior+=Behavior behavior+=Behavior*)?)
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Behavior returns EquationBehavior
	 *     EquationBehaviour returns EquationBehavior
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         parameters+=ParameterClass 
	 *         parameters+=ParameterClass* 
	 *         (localvariable+=LocalVariableClass localvariable+=LocalVariableClass*)? 
	 *         equation=Equation
	 *     )
	 */
	protected void sequence_EquationBehaviour(ISerializationContext context, EquationBehavior semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Equation returns Equation
	 *
	 * Constraint:
	 *     (left=DeclaredAttributes right=ArithmeticFCExpression)
	 */
	protected void sequence_Equation(ISerializationContext context, Equation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.EQUATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.EQUATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.EQUATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.EQUATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEquationAccess().getLeftDeclaredAttributesParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEquationAccess().getRightArithmeticFCExpressionParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Edge returns IfFalseEdge
	 *     FalseEdge returns IfFalseEdge
	 *
	 * Constraint:
	 *     (name='else' target_node+=Node)
	 */
	protected void sequence_FalseEdge(ISerializationContext context, IfFalseEdge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Fork
	 *     ControlNode returns Fork
	 *     Fork returns Fork
	 *
	 * Constraint:
	 *     (name='Fork into (' outcome_edge+=UnconditionedEdge outcome_edge+=UnconditionedEdge*)
	 */
	protected void sequence_Fork(ISerializationContext context, Fork semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GetNamedFCExpression returns FunctionCallExpression
	 *     GetAttributeFromEntityFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (
	 *         arguments+=DeclaredVariable 
	 *         function=GetVariableFunction 
	 *         (arguments+=EntityNamedFCExpression | arguments+=DeclaredEntities) 
	 *         arguments+=LocationNamedFCExpression?
	 *     )
	 */
	protected void sequence_GetAttributeFromEntityFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GetEntityFromLocationNamedFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='from'
	 */
	protected void sequence_GetEntityFromLocationNamedFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetEntityFromLocationNamedFunctionAccess().getNameFromKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GetEntityNameFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     arguments+=DeclaredEntities
	 */
	protected void sequence_GetEntityNameFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GetNamedFunction returns NamedFunction
	 *
	 * Constraint:
	 *     (name='of' | name='entity')
	 */
	protected void sequence_GetEntityNamedFunction_GetVariableFunction(ISerializationContext context, NamedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GetEntityNamedFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='entity'
	 */
	protected void sequence_GetEntityNamedFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetEntityNamedFunctionAccess().getNameEntityKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GetLocalVariableFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (function=GetVariableFunction arguments+=DeclaredVariable)
	 */
	protected void sequence_GetLocalVariableFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GetParametersFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (arguments+=DeclaredParameter function=GetVariableFunction arguments+=EntityNamedFCExpression)
	 */
	protected void sequence_GetParametersFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GetVariableFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='of'
	 */
	protected void sequence_GetVariableFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetVariableFunctionAccess().getNameOfKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InitEntity returns InitEntity
	 *
	 * Constraint:
	 *     (
	 *         initFunctionCall=EntitySetCreateFCExpression 
	 *         initName=ID 
	 *         entity+=[Entity|ID] 
	 *         (initialLocation=LocationNamedFCExpression | assingnments+=Assignment)*
	 *     )
	 */
	protected void sequence_InitEntity(ISerializationContext context, InitEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitSpace returns InitSpace
	 *
	 * Constraint:
	 *     (initFunctionCall=SpaceInitFCExpression entity+=[Entity|ID] assingnments+=Assignment*)
	 */
	protected void sequence_InitSpace(ISerializationContext context, InitSpace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Join
	 *     ControlNode returns Join
	 *     Join returns Join
	 *
	 * Constraint:
	 *     (name='Join with (' outcome_edge+=UnconditionedEdge outcome_edge+=UnconditionedEdge* outcome_edge+=UnconditionedEdge)
	 */
	protected void sequence_Join(ISerializationContext context, Join semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LocalVariableClass returns LocalVariable
	 *
	 * Constraint:
	 *     (name=ID expression=FunctionCallExpression)
	 */
	protected void sequence_LocalVariableClass(ISerializationContext context, LocalVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.VARIABLE_CLASS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.VARIABLE_CLASS__NAME));
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.LOCAL_VARIABLE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.LOCAL_VARIABLE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocalVariableClassAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLocalVariableClassAccess().getExpressionFunctionCallExpressionParserRuleCall_4_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LocationPrimitiveFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     function=LocationPrimitiveFunction
	 */
	protected void sequence_LocationPrimitiveFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.FUNCTION_CALL_EXPRESSION__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.FUNCTION_CALL_EXPRESSION__FUNCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocationPrimitiveFCExpressionAccess().getFunctionLocationPrimitiveFunctionParserRuleCall_1_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LocationNamedFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             function=MaxOneOfLocationFunction 
	 *             arguments+=DeclaredAttributes 
	 *             (arguments+=SelectConditionalLocationFCExpression | arguments+=UnionLocationFCExpression) 
	 *             arguments+=UnionLocationFCExpression?
	 *         ) | 
	 *         (
	 *             function=OneOfLocationFunction 
	 *             arguments+=SelectConditionalLocationFCExpression? 
	 *             arguments+=LocationSetNamedFCExpression? 
	 *             arguments+=DeclaredLocalVariable?
	 *         ) | 
	 *         (function=SelectConditionalLocationFunction arguments+=LocationPrimitiveFCExpression arguments+=BooleanLogicFCExpression) | 
	 *         function=LocationPrimitiveFunction
	 *     )
	 */
	protected void sequence_LocationPrimitiveFCExpression_MaxOneOfLocationFCExpression_OneOfLocationFCExpression_SelectConditionalLocationFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LocationNamedFunction returns NamedFunction
	 *
	 * Constraint:
	 *     (
	 *         name='max-one-of' | 
	 *         name='select a location' | 
	 *         name='one-of' | 
	 *         name='here' | 
	 *         name='top' | 
	 *         name='left' | 
	 *         name='right' | 
	 *         name='grid' | 
	 *         name='bottom' | 
	 *         name='neighborhood' | 
	 *         name='neighborhood' | 
	 *         name='grid' | 
	 *         name='union-location'
	 *     )
	 */
	protected void sequence_LocationPrimitiveFunction_MaxOneOfLocationFunction_NeighborhoodLocationFunction_OneOfLocationFunction_SelectConditionalLocationFunction_SpaceLocationFunction_UnionLocationFunction(ISerializationContext context, NamedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleLocationNamedFunction returns NamedFunction
	 *
	 * Constraint:
	 *     (
	 *         name='max-one-of' | 
	 *         name='select a location' | 
	 *         name='one-of' | 
	 *         name='here' | 
	 *         name='top' | 
	 *         name='left' | 
	 *         name='right' | 
	 *         name='grid' | 
	 *         name='bottom' | 
	 *         name='neighborhood'
	 *     )
	 */
	protected void sequence_LocationPrimitiveFunction_MaxOneOfLocationFunction_OneOfLocationFunction_SelectConditionalLocationFunction(ISerializationContext context, NamedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LocationPrimitiveFunction returns NamedFunction
	 *
	 * Constraint:
	 *     (
	 *         name='here' | 
	 *         name='top' | 
	 *         name='left' | 
	 *         name='right' | 
	 *         name='grid' | 
	 *         name='bottom' | 
	 *         name='neighborhood'
	 *     )
	 */
	protected void sequence_LocationPrimitiveFunction(ISerializationContext context, NamedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MathFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (function=MathFunction arguments+=NumericNamedFCExpression)
	 */
	protected void sequence_MathFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MaxOneOfLocationFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (
	 *         function=MaxOneOfLocationFunction 
	 *         arguments+=DeclaredAttributes 
	 *         (arguments+=SelectConditionalLocationFCExpression | arguments+=UnionLocationFCExpression) 
	 *         arguments+=UnionLocationFCExpression?
	 *     )
	 */
	protected void sequence_MaxOneOfLocationFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MaxOneOfLocationFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='max-one-of'
	 */
	protected void sequence_MaxOneOfLocationFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMaxOneOfLocationFunctionAccess().getNameMaxOneOfKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Merge
	 *     ControlNode returns Merge
	 *     Merge returns Merge
	 *
	 * Constraint:
	 *     (name='Merge with (' outcome_edge+=UnconditionedEdge outcome_edge+=UnconditionedEdge* outcome_edge+=UnconditionedEdge)
	 */
	protected void sequence_Merge(ISerializationContext context, Merge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=ID entities+=Entity* mainBehavior=Behavior init+=InitEntity* init+=InitSpace*)*
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Move
	 *     ExcecutableNode returns Move
	 *     PrimitiveActivities returns Move
	 *     Move returns Move
	 *
	 * Constraint:
	 *     (name='Move to ' (locationexpression=DeclaredLocalVariable | locationexpression=LocationNamedFCExpression) outcome_edge+=UnconditionedEdge)
	 */
	protected void sequence_Move(ISerializationContext context, Move semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NeighborFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     function=NeighborhoodLocationFunction
	 */
	protected void sequence_NeighborFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.FUNCTION_CALL_EXPRESSION__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.FUNCTION_CALL_EXPRESSION__FUNCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNeighborFCExpressionAccess().getFunctionNeighborhoodLocationFunctionParserRuleCall_1_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LocationSetNamedFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (
	 *         (function=UnionLocationFunction arguments+=LocationNamedFCExpression arguments+=LocationNamedFCExpression*) | 
	 *         function=NeighborhoodLocationFunction | 
	 *         (function=SpaceLocationFunction arguments+=DeclaredEntities (arguments+=BooleanLogicFCExpression arguments+=BooleanLogicFCExpression*)?)
	 *     )
	 */
	protected void sequence_NeighborFCExpression_SpaceFCExpression_UnionLocationFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NeighborhoodLocationFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='neighborhood'
	 */
	protected void sequence_NeighborhoodLocationFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNeighborhoodLocationFunctionAccess().getNameNeighborhoodKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LocationSetNamedFunction returns NamedFunction
	 *
	 * Constraint:
	 *     (name='neighborhood' | name='grid' | name='union-location')
	 */
	protected void sequence_NeighborhoodLocationFunction_SpaceLocationFunction_UnionLocationFunction(ISerializationContext context, NamedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OneOfLocationFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (
	 *         function=OneOfLocationFunction 
	 *         arguments+=SelectConditionalLocationFCExpression? 
	 *         arguments+=LocationSetNamedFCExpression? 
	 *         arguments+=DeclaredLocalVariable?
	 *     )
	 */
	protected void sequence_OneOfLocationFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OneOfLocationFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='one-of'
	 */
	protected void sequence_OneOfLocationFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOneOfLocationFunctionAccess().getNameOneOfKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParameterClass returns ParameterClass
	 *
	 * Constraint:
	 *     (name=ID type=TypeEnum)
	 */
	protected void sequence_ParameterClass(ISerializationContext context, ParameterClass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.VARIABLE_CLASS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.VARIABLE_CLASS__NAME));
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.VARIABLE_CLASS__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.VARIABLE_CLASS__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterClassAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterClassAccess().getTypeTypeEnumEnumRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     QuantififiedLocation returns NamedFunction
	 *
	 * Constraint:
	 *     (name='any' | name='all' | name='random')
	 */
	protected void sequence_QuantififiedLocation(ISerializationContext context, NamedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Remove
	 *     ExcecutableNode returns Remove
	 *     PrimitiveActivities returns Remove
	 *     Remove returns Remove
	 *
	 * Constraint:
	 *     (name='Remove' expression+=FunctionCallExpression from=DeclaredAttributes outcome_edge+=UnconditionedEdge?)
	 */
	protected void sequence_Remove(ISerializationContext context, Remove semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Reproduce
	 *     ExcecutableNode returns Reproduce
	 *     PrimitiveActivities returns Reproduce
	 *     Reproduce returns Reproduce
	 *
	 * Constraint:
	 *     (
	 *         name='Reproduce' 
	 *         offspring_quantity=ConstantExpression 
	 *         declaredattributes+=SetAttributeNamedFCExpression 
	 *         declaredattributes+=SetAttributeNamedFCExpression* 
	 *         initial_location=LocationNamedFCExpression 
	 *         occupiedExpression+=BooleanIsOccuppiedLocationFCExpression? 
	 *         outcome_edge+=UnconditionedEdge?
	 *     )
	 */
	protected void sequence_Reproduce(ISerializationContext context, Reproduce semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelectConditionalLocationFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (function=SelectConditionalLocationFunction arguments+=LocationPrimitiveFCExpression arguments+=BooleanLogicFCExpression)
	 */
	protected void sequence_SelectConditionalLocationFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelectConditionalLocationFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='select a location'
	 */
	protected void sequence_SelectConditionalLocationFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelectConditionalLocationFunctionAccess().getNameSelectALocationKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SetAttributeNamedFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (arguments+=DeclaredAttributes arguments+=ConstantExpression?)
	 */
	protected void sequence_SetAttributeNamedFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SetNamedFunctionExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     ((arguments+=DeclaredAttributes arguments+=ConstantExpression?) | (arguments+=DeclaredAttributes arguments+=LocationNamedFCExpression))
	 */
	protected void sequence_SetAttributeNamedFCExpression_SetLocationNamedFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SetLocationNamedFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (arguments+=DeclaredAttributes arguments+=LocationNamedFCExpression)
	 */
	protected void sequence_SetLocationNamedFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns SetVariable
	 *     ExcecutableNode returns SetVariable
	 *     PrimitiveActivities returns SetVariable
	 *     Set returns SetVariable
	 *
	 * Constraint:
	 *     (name='Set' assignment=Assignment outcome_edge+=UnconditionedEdge?)
	 */
	protected void sequence_Set(ISerializationContext context, SetVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpaceFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (function=SpaceLocationFunction arguments+=DeclaredEntities (arguments+=BooleanLogicFCExpression arguments+=BooleanLogicFCExpression*)?)
	 */
	protected void sequence_SpaceFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpaceInitFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (function=SpaceInitFunction arguments+=DeclaredEntities arguments+=ConstantExpression arguments+=ConstantExpression)
	 */
	protected void sequence_SpaceInitFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpaceInitFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='Create grid'
	 */
	protected void sequence_SpaceInitFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpaceInitFunctionAccess().getNameCreateGridKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpaceLocationFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='grid'
	 */
	protected void sequence_SpaceLocationFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpaceLocationFunctionAccess().getNameGridKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Start
	 *     ControlNode returns Start
	 *     Start returns Start
	 *
	 * Constraint:
	 *     (name='Start' outcome_edge+=UnconditionedEdge)
	 */
	protected void sequence_Start(ISerializationContext context, Start semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Edge returns IfTrueEdge
	 *     TrueEdge returns IfTrueEdge
	 *
	 * Constraint:
	 *     (name='then' target_node+=Node)
	 */
	protected void sequence_TrueEdge(ISerializationContext context, IfTrueEdge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     type=TypeEnum
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getTypeTypeEnumEnumRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MathFunction returns NamedFunction
	 *     UnaryMathBinaryFunction returns NamedFunction
	 *
	 * Constraint:
	 *     (name='sqrt' | name='random' | name='floor' | name='exp')
	 */
	protected void sequence_UnaryMathBinaryFunction(ISerializationContext context, NamedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Edge returns UnconditionedEdge
	 *     UnconditionedEdge returns UnconditionedEdge
	 *
	 * Constraint:
	 *     (
	 *         name='->' 
	 *         (
	 *             target_node+=DeclaredBehavior | 
	 *             target_node+=End | 
	 *             target_node+=Decision | 
	 *             target_node+=Fork | 
	 *             target_node+=Merge | 
	 *             target_node+=Join | 
	 *             target_node+=PrimitiveActivities
	 *         )
	 *     )
	 */
	protected void sequence_UnconditionedEdge(ISerializationContext context, UnconditionedEdge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnionLocationFCExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (function=UnionLocationFunction arguments+=LocationNamedFCExpression arguments+=LocationNamedFCExpression*)
	 */
	protected void sequence_UnionLocationFCExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnionLocationFunction returns NamedFunction
	 *
	 * Constraint:
	 *     name='union-location'
	 */
	protected void sequence_UnionLocationFunction(ISerializationContext context, NamedFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetamodelPackage.Literals.NAMED_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnionLocationFunctionAccess().getNameUnionLocationKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
